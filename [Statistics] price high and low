//@version=6
indicator("[Statistics] price high and low", overlay = true)

// === INPUTS HERE===

// --- General Settings ---
var string GRP_GENERAL = "General Settings"
i_hourlyTimezone = input.string("America/New_York", "Timezone (Custom, Session)", options = [
     // Americas (North)
     "America/Los_Angeles", "America/Vancouver", "America/Phoenix", "America/Denver", "America/Chicago", "America/Mexico_City", "America/New_York", "America/Toronto", 
     // Americas (South)
     "America/Bogota", "America/Lima", "America/Caracas", "America/Santiago", "America/Buenos_Aires", "America/Sao_Paulo",
     // Europe
     "Europe/London", "Europe/Dublin", "Europe/Lisbon", "Europe/Paris", "Europe/Berlin", "Europe/Madrid", "Europe/Rome", "Europe/Stockholm", "Europe/Zurich", "Europe/Athens", "Europe/Helsinki", "Europe/Amsterdam", "Europe/Oslo", "Europe/Warsaw",
     // Europe/Middle East
     "Europe/Moscow", "Europe/Istanbul", "Asia/Jerusalem", "Asia/Dubai", "Asia/Tehran", "Asia/Riyadh",
     // Asia/Pacific
     "Asia/Karachi", "Asia/Kolkata", "Asia/Bangkok", "Asia/Ho_Chi_Minh", "Asia/Singapore", "Asia/Hong_Kong", "Asia/Shanghai", "Asia/Taipei", "Asia/Seoul", "Asia/Tokyo", 
     // Australia/Pacific
     "Australia/Perth", "Australia/Sydney", "Australia/Adelaide", "Australia/Brisbane", "Pacific/Auckland", "Pacific/Honolulu",
     // UTC
     "Etc/UTC"
     ], group = GRP_GENERAL, tooltip = "Selects the reference timezone. Used for the Custom and Session tables to correctly handle Daylight Saving Time (DST) shifts.") 
i_dividerColor = input.color(color.new(color.white, 0), "Divider Color (All Modules)", group = GRP_GENERAL, tooltip = "Selects the color for all enabled dividers.") 
i_showDividerLabels = input.bool(true, "Show Divider Labels", group = GRP_GENERAL, tooltip = "Adds text labels (e.g., 'Weekly', 'Session Start') to the bottom of all enabled dividers.")
// FIX: Updated tooltip to describe fading
i_highlightActiveTimezone = input.bool(true, "Fade Inactive STD/DST Column", group = GRP_GENERAL, tooltip = "If checked, the text of the inactive time column (STD or DST) will be 'faded' (set to gray) in the Custom and Session tables.") 

// --- Daily Analysis Settings ---
var string GRP_DAILY = "Daily High/Low of the Week" 
i_enableDailyLogic = input.bool(true, "Enable Daily Analysis", group = GRP_DAILY, tooltip = "Enables the 'Daily high and low of the week' analysis. This logic only runs when the chart timeframe is set to 1D.") 
i_showDivider_D = input.bool(false, "Show Weekly Divider", group = GRP_DAILY, tooltip = "Shows a vertical divider at the start of every week. Only visible when Daily Analysis is enabled.") 
i_showDailyTable = input.bool(true, "Show table", inline = "table_d", group = GRP_DAILY, tooltip = "Shows/hides the statistics table for the Daily analysis.") 
i_tablePos_D = input.string(position.bottom_right, "Table Position", options = [position.top_left, position.top_right, position.middle_left, position.middle_right, position.bottom_left, position.bottom_right], group = GRP_DAILY, tooltip = "Selects the table's position on the chart.") 
i_tableSize_D = input.string(size.normal, "Table Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_DAILY, tooltip = "Selects the table's font size.") 
i_showSun = input.bool(false, "Show Sunday", inline = "days", group = GRP_DAILY, tooltip = "Shows/hides the 'Sunday' row in the Daily table.") 
i_showSat = input.bool(false, "Show Saturday", inline = "days", group = GRP_DAILY, tooltip = "Shows/hides the 'Saturday' row in the Daily table.") 

i_showLabels_D = input.bool(false, "Show labels", group = GRP_DAILY, tooltip = "Shows/hides the labels on the 1D chart for the bar that made the high or low of the week.") 
i_howLabelColor_D = input.color(color.new(color.teal, 70), "HOW Label", group = GRP_DAILY, tooltip = "Selects the color for the 'Daily High of the Week' label.") 
i_lowLabelColor_D = input.color(color.new(color.red, 70), "LOW Label", group = GRP_DAILY, tooltip = "Selects the color for the 'Daily Low of the Week' label.") 

// --- Monthly (WOM) Analysis Settings ---
var string GRP_WOM = "Weekly High/Low of the Month" 
i_enableWOMLogic = input.bool(false, "Enable 'Week of Month' Analysis", group = GRP_WOM, tooltip = "Enables the 'Weekly high and low of the month' analysis. This logic only runs when the chart timeframe is set to 1W.") 
i_showDivider_WOM = input.bool(false, "Show Monthly Divider", group = GRP_WOM, tooltip = "Shows a vertical divider at the start of every month. Only visible when 'Week of Month' Analysis is enabled.") 
i_showWOMTable = input.bool(true, "Show table", inline = "table_wom", group = GRP_WOM, tooltip = "Shows/hides the statistics table for the 'Week of Month' analysis.") 
i_tablePos_WOM = input.string(position.bottom_right, "Table Position", options = [position.top_left, position.top_right, position.middle_left, position.middle_right, position.bottom_left, position.bottom_right], group = GRP_WOM, tooltip = "Selects the table's position on the chart.") 
i_tableSize_WOM = input.string(size.normal, "Table Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_WOM, tooltip = "Selects the table's font size.") 

i_showLabels_WOM = input.bool(false, "Show labels", group = GRP_WOM, tooltip = "Shows/hides the labels on the 1W chart for the bar that made the high or low of the month.") 
i_howLabelColor_WOM = input.color(color.new(color.teal, 70), "MOH Label", group = GRP_WOM, tooltip = "Selects the color for the 'Weekly High of the Month' label.") 
i_lowLabelColor_WOM = input.color(color.new(color.red, 70), "MOL Label", group = GRP_WOM, tooltip = "Selects the color for the 'Weekly Low of the Month' label.") 


// --- Yearly (MOY) Analysis Settings ---
var string GRP_MOY = "Monthly High/Low of the Year" 
i_enableMOYLogic = input.bool(false, "Enable 'Month of Year' Analysis", group = GRP_MOY, tooltip = "Enables the 'Monthly high and low of the year' analysis. This logic only runs when the chart timeframe is set to 1M.") 
i_showDivider_MOY = input.bool(false, "Show Yearly Divider", group = GRP_MOY, tooltip = "Shows a vertical divider at the start of every year. Only visible when 'Month of Year' Analysis is enabled.") 
i_showMOYTable = input.bool(true, "Show table", inline = "table_moy", group = GRP_MOY, tooltip = "Shows/hides the statistics table for the 'Month of Year' analysis.") 
i_tablePos_MOY = input.string(position.bottom_right, "Table Position", options = [position.top_left, position.top_right, position.middle_left, position.middle_right, position.bottom_left, position.bottom_right], group = GRP_MOY, tooltip = "Selects the table's position on the chart.") 
i_tableSize_MOY = input.string(size.normal, "Table Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_MOY, tooltip = "Selects the table's font size.") 

i_showLabels_MOY = input.bool(false, "Show labels", group = GRP_MOY, tooltip = "Shows/hides the labels on the 1M chart for the bar that made the high or low of the year.") 
i_howLabelColor_MOY = input.color(color.new(color.teal, 70), "HOY Label", group = GRP_MOY, tooltip = "Selects the color for the 'Monthly High of the Year' label.") 
i_lowLabelColor_MOY = input.color(color.new(color.red, 70), "LOY Label", group = GRP_MOY, tooltip = "Selects the color for the 'Monthly Low of the Year' label.") 

// --- Custom Timeframe Analysis Settings ---
var string GRP_C = "Custom Timeframe Analysis"
i_enableCustomLogic = input.bool(false, "Enable Custom Analysis", group = GRP_C, tooltip = "Enables the 'Custom' analysis. This module runs on your CURRENT chart timeframe (LTF) as long as it's LOWER than the 'Higher Timeframe' you select below.") 
i_customHTF = input.timeframe("1D", "Higher Timeframe", group = GRP_C, tooltip = "Select the 'Higher Timeframe' (HTF) to analyze. The script will find the high/low of this period using data from your current chart timeframe (LTF). E.g., Set HTF to '1D' and view a '5m' chart to find the 5m candle that makes the daily high/low.")
i_showDivider_C = input.bool(false, "Show HTF Divider", group = GRP_C, tooltip = "Shows a vertical divider at the start of every 'Higher Timeframe' period.") 
i_showCustomTable = input.bool(true, "Show table", inline = "table_c", group = GRP_C, tooltip = "Shows/hides the statistics table for the Custom analysis.") 
i_tablePos_C = input.string(position.bottom_right, "Table Position", options = [position.top_left, position.top_right, position.middle_left, position.middle_right, position.bottom_left, position.bottom_right], group = GRP_C, tooltip = "Selects the table's position on the chart.") 
i_tableSize_C = input.string(size.normal, "Table Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_C, tooltip = "Selects the table's font size.") 
i_limitCustomRows = input.bool(true, "Limit Table Rows", group = GRP_C, tooltip = "If checked, the table will only show the 'Top N' most frequent candle times, based on the 'Max Table Rows' setting.")
i_maxCustomRows = input.int(20, "Max Table Rows", minval = 1, group = GRP_C, tooltip = "Sets the maximum number of rows to display in the Custom table. The table will show the most frequent (HOW + LOW) candle times.")

i_showLabels_C = input.bool(false, "Show labels", group = GRP_C, tooltip = "Shows/hides the labels on the chart for the LTF bar that made the high or low of the HTF period.") 
i_howLabelColor_C = input.color(color.new(color.teal, 70), "High Label", group = GRP_C, tooltip = "Selects the color for the 'High' label.") 
i_lowLabelColor_C = input.color(color.new(color.red, 70), "Low Label", group = GRP_C, tooltip = "Selects the color for the 'Low' label.") 

// --- Session Statistics Settings (REORGANIZED) ---
var string GRP_SESS = "Session High/Low Statistics"
i_enableSessionLogic = input.bool(false, "Enable Session Analysis", group = GRP_SESS, tooltip = "Enables the 'Session' analysis. This module runs on intraday timeframes (e.g., 5m, 1H) and analyzes a specific time window you define.")
i_session_S = input.session("0930-1600", "Session", group = GRP_SESS, tooltip = "Session time in 24-hour HHMM-HHMM format. E.g., 0930-1600. Session end is exclusive (e.g., 1600 means the session ends at 15:59:59). Uses the 'Timezone' from 'General Settings'.")

i_showDividers_S = input.bool(true, "Show Dividers", group = GRP_SESS, tooltip = "Shows vertical dotted dividers at the start and end of the session. Uses the 'Divider Color' from General Settings.")

i_showTable_S = input.bool(true, "Show Table", inline = "table_s", group = GRP_SESS, tooltip = "Shows/hides the statistics table.") 
i_tablePos_S = input.string(position.bottom_right, "Table Position", options = [position.top_left, position.top_right, position.middle_left, position.middle_right, position.bottom_left, position.bottom_right], group = GRP_SESS) 
i_tableSize_S = input.string(size.normal, "Table Size", options = [size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_SESS) 
i_limitRows_S = input.bool(true, "Limit Table Rows", group = GRP_SESS, tooltip = "If checked, the table will only show the 'Top N' most frequent candle times, based on the 'Max Table Rows' setting.")
i_maxRows_S = input.int(20, "Max Table Rows", minval = 1, group = GRP_SESS, tooltip = "Sets the maximum number of rows to display.")

i_showLabels_S = input.bool(false, "Show Labels", group = GRP_SESS, tooltip = "Shows/hides labels on the chart for the candle that made the high or low of the session.") 
i_highLabelColor_S = input.color(color.new(color.teal, 70), "High Label", group = GRP_SESS) 
i_lowLabelColor_S = input.color(color.new(color.red, 70), "Low Label", group = GRP_SESS) 


// === CONSTANTS ===
// Lookbacks are now hard-coded to the max value
int MAX_LOOKBACK = 500


// === TIMEFRAME CHECKS ===
int SECS_IN_DAY = 86400
int chartSecs = timeframe.in_seconds(timeframe.period)
int chartDurationInMinutes = chartSecs / 60

bool runDailyLogic = i_enableDailyLogic and (timeframe.isdaily and timeframe.multiplier == 1)
bool runWOMLogic = i_enableWOMLogic and (timeframe.isweekly and timeframe.multiplier == 1)
bool runMOYLogic = i_enableMOYLogic and (timeframe.ismonthly and timeframe.multiplier == 1)
bool runCustomLogic = i_enableCustomLogic and chartSecs < timeframe.in_seconds(i_customHTF)
bool runSessionLogic = i_enableSessionLogic and (chartSecs < SECS_IN_DAY) // Session logic runs on any intraday TF


// === DAILY (HOW/LOW) VARIABLES ===
var float weekHigh_D = na
var float weekLow_D = na
var int   dayOfHOW_D = na
var int   dayOfLOW_D = na
var int   barOfHOW_D = na
var int   barOfLOW_D = na
var int[] howHistory_D = array.new_int()
var int[] lowHistory_D = array.new_int()

// === MONTHLY (WOM) VARIABLES ===
var float monthHigh_D = na
var float monthLow_D = na
var int   weekOfMOH_D = na // Week of Month's High
var int   weekOfMOL_D = na // Week of Month's Low
var int   barOfMOH_D = na  // Bar of Month's High
var int   barOfMOL_D = na  // Bar of Month's Low
var int[] mohHistory = array.new_int() // Month's High History
var int[] molHistory = array.new_int() // Month's Low History

// === YEARLY (MOY) VARIABLES ===
var float yearHigh_D = na
var float yearLow_D = na
var int   monthOfYOH_D = na // Month of Year's High
var int   monthOfYOL_D = na // Month of Year's Low
var int   barOfYOH_D = na    // Bar of Year's High
var int   barOfYOL_D = na    // Bar of Year's Low
var int[] moyhHistory = array.new_int() // Year's High History
var int[] molyHistory = array.new_int() // Year's Low History

// === CUSTOM (HTF/LTF) VARIABLES ===
var float htfHigh_C = na 
var float htfLow_C = na 
var int   utcMinutesOfHOW_C = na 
var int   utcMinutesOfLOW_C = na 
var int   localDayOfHOW_C = na 
var int   localHourOfHOW_C = na 
var int   localMinuteOfHOW_C = na 
var int   localDayOfLOW_C = na 
var int   localHourOfLOW_C = na 
var int   localMinuteOfLOW_C = na 
var int   barOfHOW_C = na 
var int   barOfLOW_C = na 
var int   offsetOfHOW_C = na 
var int   offsetOfLOW_C = na 
var int[] howHistory_C = array.new_int() 
var int[] lowHistory_C = array.new_int() 
var int[] offsetHistory_C = array.new_int()

// === SESSION (NEW) VARIABLES ===
var int[] howHistory_S = array.new_int()
var int[] lowHistory_S = array.new_int()
var int[] offsetHistory_S = array.new_int() 
var float sessionHigh_S = na
var float sessionLow_S = na
var int   barOfHigh_S = na
var int   barOfLow_S = na
var int   utcMinutesOfHigh_S = na
var int   utcMinutesOfLow_S = na
var int   localHourOfHigh_S = na
var int   localMinOfHigh_S = na
var int   localHourOfLow_S = na
var int   localMinOfLow_S = na
var int   offsetOfHigh_S = na
var int   offsetOfLow_S = na


// === SESSION STATE CALCULATION (NEW) ===
// These must be calculated globally for history (e.g., inSession_S[1]) to work.
// Parse the session string
string[] sessionTimes_S = str.split(i_session_S, "-")
string startTimeStr_S = array.get(sessionTimes_S, 0)
string endTimeStr_S = array.get(sessionTimes_S, 1)

int sessionStartHour_S = int(str.tonumber(str.substring(startTimeStr_S, 0, 2)))
int sessionStartMin_S = int(str.tonumber(str.substring(startTimeStr_S, 2, 4)))
int sessionEndHour_S = int(str.tonumber(str.substring(endTimeStr_S, 0, 2)))
int sessionEndMin_S = int(str.tonumber(str.substring(endTimeStr_S, 2, 4)))

// Session Time (in minutes from midnight)
int startMinutes_S = (sessionStartHour_S * 60) + sessionStartMin_S
int endMinutes_S = (sessionEndHour_S * 60) + sessionEndMin_S

// Current Time (in minutes from midnight, based on selected timezone)
int localHour_S = hour(time, i_hourlyTimezone)
int localMinute_S = minute(time, i_hourlyTimezone)
int localMinutes_S = (localHour_S * 60) + localMinute_S

// Session State Booleans
bool isOvernight_S = startMinutes_S > endMinutes_S
bool inSession_S = isOvernight_S ? (localMinutes_S >= startMinutes_S or localMinutes_S < endMinutes_S) : (localMinutes_S >= startMinutes_S and localMinutes_S < endMinutes_S)
// Only trigger start/end if the module is enabled
bool isSessionStart_S = i_enableSessionLogic and inSession_S and not inSession_S[1]
bool isSessionEnd_S = i_enableSessionLogic and not inSession_S and inSession_S[1]


// === HELPER FUNCTIONS ===
f_dayToString(day) =>
    string dayStr = ""
    if day == dayofweek.sunday
        dayStr := "Sun"
    else if day == dayofweek.monday
        dayStr := "Mon"
    else if day == dayofweek.tuesday
        dayStr := "Tue"
    else if day == dayofweek.wednesday
        dayStr := "Wed"
    else if day == dayofweek.thursday
        dayStr := "Thu"
    else if day == dayofweek.friday
        dayStr := "Fri"
    else if day == dayofweek.saturday
        dayStr := "Sat"
    dayStr

f_monthToString(monthNum) =>
    string monthStr = ""
    if monthNum == 1
        monthStr := "Jan"
    else if monthNum == 2
        monthStr := "Feb"
    else if monthNum == 3
        monthStr := "Mar"
    else if monthNum == 4
        monthStr := "Apr"
    else if monthNum == 5
        monthStr := "May"
    else if monthNum == 6
        monthStr := "Jun"
    else if monthNum == 7
        monthStr := "Jul"
    else if monthNum == 8
        monthStr := "Aug"
    else if monthNum == 9
        monthStr := "Sep"
    else if monthNum == 10
        monthStr := "Oct"
    else if monthNum == 11
        monthStr := "Nov"
    else if monthNum == 12
        monthStr := "Dec"
    monthStr

// Formats hour and minute (e.g., "09:15") for labels and Custom/Session table
f_timeToString(h, m) =>
    int safeHour = (h % 24 + 24) % 24
    int safeMinute = (m % 60 + 60) % 60
    str.format("{0,number,00}:{1,number,00}", safeHour, safeMinute)

// FIX: New function to format timeframe strings for labels/tables
f_formatTimeframe(tf) =>
    string formattedTf = ""
    if str.contains(tf, "M")
        formattedTf := tf // Already formatted (e.g., "1M")
    else if str.contains(tf, "W")
        formattedTf := tf // Already formatted (e.g., "1W")
    else if str.contains(tf, "D")
        formattedTf := tf // Already formatted (e.g., "1D")
    else
        // It's minutes, convert to number
        int minutes = int(nz(str.tonumber(tf))) // FIX: Use str.tonumber() and cast to int
        if minutes == 0
            formattedTf := tf // Failsafe
        else if minutes < 60
            formattedTf := str.tostring(minutes) + "m" // Use 'm' for minutes
        else
            formattedTf := str.tostring(minutes / 60) + "H" // 1H, 4H, etc.
    formattedTf


// WORKAROUND: Manually calculate the UTC offset in hours
f_calculateOffset(t, tz) =>
    int utc_day = dayofmonth(t, "Etc/UTC")
    int local_day = dayofmonth(t, tz)
    int utc_hour = hour(t, "Etc/UTC")
    int local_hour = hour(t, tz)
   
    int day_diff = local_day - utc_day
    if day_diff > 1
        day_diff := -1 
    else if day_diff < -1
        day_diff := 1 
       
    int hour_diff = local_hour - utc_hour
    int offset = (day_diff * 24) + hour_diff
    offset


// === LOGIC ===
bool isNewWeek = timeframe.change("W")
bool isNewMonth = timeframe.change("M")
bool isNewYear = timeframe.change("12M") 
bool isNewDay = timeframe.change("D")
bool isNewCustomHTF = timeframe.change(i_customHTF) 

// --- DAILY LOGIC BLOCK (Table, Daily Labels) ---
if runDailyLogic 
    if isNewWeek
        int   finalizedDayOfHOW_D = dayOfHOW_D[1]
        int   finalizedDayOfLOW_D = dayOfLOW_D[1]
        int   finalizedBarOfHOW_D = barOfHOW_D[1]
        int   finalizedBarOfLOW_D = barOfLOW_D[1]
        float finalizedWeekHigh_D = weekHigh_D[1]
        float finalizedWeekLow_D  = weekLow_D[1]

        if i_showLabels_D
            string howDayStr = f_dayToString(finalizedDayOfHOW_D)
            string lowDayStr = f_dayToString(finalizedDayOfLOW_D)
            if not na(finalizedBarOfHOW_D)
                label.new(finalizedBarOfHOW_D, finalizedWeekHigh_D, "Daily High of the Week\n" + howDayStr, yloc = yloc.abovebar, color = i_howLabelColor_D, textcolor = color.white, style = label.style_label_down) 
            if not na(finalizedBarOfLOW_D)
                label.new(finalizedBarOfLOW_D, finalizedWeekLow_D, "Daily Low of the Week\n" + lowDayStr, yloc = yloc.belowbar, color = i_lowLabelColor_D, textcolor = color.white, style = label.style_label_up) 

        if not na(finalizedDayOfHOW_D)
            array.push(howHistory_D, finalizedDayOfHOW_D)
        if not na(finalizedDayOfLOW_D)
            array.push(lowHistory_D, finalizedDayOfLOW_D)

        while array.size(howHistory_D) > MAX_LOOKBACK
            array.shift(howHistory_D)
        while array.size(lowHistory_D) > MAX_LOOKBACK
            array.shift(lowHistory_D)

        weekHigh_D := high
        weekLow_D  := low
        dayOfHOW_D := dayofweek
        dayOfLOW_D := dayofweek
        barOfHOW_D := bar_index
        barOfLOW_D := bar_index
    else
        if high > weekHigh_D
            weekHigh_D := high
            dayOfHOW_D := dayofweek
            barOfHOW_D := bar_index
        if low < weekLow_D
            weekLow_D  := low
            dayOfLOW_D := dayofweek
            barOfLOW_D := bar_index

// --- MONTHLY (WOM) LOGIC BLOCK ---
if runWOMLogic 
    // v6 WORKAROUND: Manually calculate week of month to avoid 'time' namespace error
    int currentWeekOfMonth = math.floor((dayofmonth - 1) / 7) + 1

    if isNewMonth
        // Finalize previous month's data
        int finalizedWeekOfMOH = weekOfMOH_D[1]
        int finalizedWeekOfMOL = weekOfMOL_D[1]
        int finalizedBarOfMOH = barOfMOH_D[1]
        int finalizedBarOfMOL = barOfMOL_D[1]
        float finalizedMonthHigh = monthHigh_D[1]
        float finalizedMonthLow = monthLow_D[1]
        int finalizedMonth = month[1] // Get the month number of the completed month

        if i_showLabels_WOM
            string womMonthStr = f_monthToString(finalizedMonth) // Convert month number to string
            if not na(finalizedBarOfMOH)
                label.new(finalizedBarOfMOH, finalizedMonthHigh, "Weekly High of the Month\n" + womMonthStr, yloc = yloc.abovebar, color = i_howLabelColor_WOM, textcolor = color.white, style = label.style_label_down) 
            if not na(finalizedBarOfMOL)
                label.new(finalizedBarOfMOL, finalizedMonthLow, "Weekly Low of the Month\n" + womMonthStr, yloc = yloc.belowbar, color = i_lowLabelColor_WOM, textcolor = color.white, style = label.style_label_up) 
       
        if not na(finalizedWeekOfMOH)
            array.push(mohHistory, finalizedWeekOfMOH)
        if not na(finalizedWeekOfMOL)
            array.push(molHistory, finalizedWeekOfMOL)
           
        // Prune history
        while array.size(mohHistory) > MAX_LOOKBACK
            array.shift(mohHistory)
        while array.size(molHistory) > MAX_LOOKBACK
            array.shift(molHistory)
           
        // Reset trackers for new month
        monthHigh_D := high
        monthLow_D  := low
        weekOfMOH_D := currentWeekOfMonth 
        weekOfMOL_D := currentWeekOfMonth 
        barOfMOH_D := bar_index
        barOfMOL_D := bar_index
    else
        // Update trackers during the month
        if high > monthHigh_D
            monthHigh_D := high
            weekOfMOH_D := currentWeekOfMonth
            barOfMOH_D := bar_index
        if low < monthLow_D
            monthLow_D := low
            weekOfMOL_D := currentWeekOfMonth
            barOfMOL_D := bar_index

// --- YEARLY (MOY) LOGIC BLOCK ---
if runMOYLogic 
    if isNewYear
        // Finalize previous year's data
        int finalizedMonthOfYOH = monthOfYOH_D[1]
        int finalizedMonthOfYOL = monthOfYOL_D[1]
        int finalizedBarOfYOH = barOfYOH_D[1]
        int finalizedBarOfYOL = barOfYOL_D[1]
        float finalizedYearHigh = yearHigh_D[1]
        float finalizedYearLow = yearLow_D[1]

        if i_showLabels_MOY
            string hoyMonthStr = f_monthToString(finalizedMonthOfYOH)
            string loyMonthStr = f_monthToString(finalizedMonthOfYOL)
            if not na(finalizedBarOfYOH)
                label.new(finalizedBarOfYOH, finalizedYearHigh, "Monthly High of the Year\n" + hoyMonthStr, yloc = yloc.abovebar, color = i_howLabelColor_MOY, textcolor = color.white, style = label.style_label_down) 
            if not na(finalizedBarOfYOL)
                label.new(finalizedBarOfYOL, finalizedYearLow, "Monthly Low of the Year\n" + loyMonthStr, yloc = yloc.belowbar, color = i_lowLabelColor_MOY, textcolor = color.white, style = label.style_label_up) 
       
        if not na(finalizedMonthOfYOH)
            array.push(moyhHistory, finalizedMonthOfYOH)
        if not na(finalizedMonthOfYOL)
            array.push(molyHistory, finalizedMonthOfYOL)
           
        // Prune history
        while array.size(moyhHistory) > MAX_LOOKBACK
            array.shift(moyhHistory)
        while array.size(molyHistory) > MAX_LOOKBACK 
            array.shift(molyHistory)
           
        // Reset trackers for new year
        yearHigh_D := high
        yearLow_D  := low
        monthOfYOH_D := month
        monthOfYOL_D := month
        barOfYOH_D := bar_index
        barOfYOL_D := bar_index
    else
        // Update trackers during the year
        if high > yearHigh_D
            yearHigh_D := high
            monthOfYOH_D := month
            barOfYOH_D := bar_index
        if low < yearLow_D
            yearLow_D := low
            monthOfYOL_D := month
            barOfYOL_D := bar_index

// --- CUSTOM LOGIC BLOCK (Table, Custom Labels) ---
if runCustomLogic
    // FIX: Track minutes from midnight, not just the hour
    int currentUtcMinutes_C = (hour(time, "Etc/UTC") * 60) + minute(time, "Etc/UTC") 
    int currentLocalHour_C = hour(time, i_hourlyTimezone)
    int currentLocalMinute_C = minute(time, i_hourlyTimezone)
    int currentLocalDay_C = dayofweek(time, i_hourlyTimezone)
    int currentOffset_C = f_calculateOffset(time, i_hourlyTimezone)

    if isNewCustomHTF // Trigger on the custom HTF change
        // Finalize previous period's data
        int   finalizedUtcMinutesOfHOW_C = utcMinutesOfHOW_C[1] // FIX: Renamed
        int   finalizedUtcMinutesOfLOW_C = utcMinutesOfLOW_C[1] // FIX: Renamed
        int   finalizedLocalDayOfHOW_C = localDayOfHOW_C[1] 
        int   finalizedLocalHourOfHOW_C = localHourOfHOW_C[1] 
        int   finalizedLocalMinuteOfHOW_C = localMinuteOfHOW_C[1] 
        int   finalizedLocalDayOfLOW_C = localDayOfLOW_C[1] 
        int   finalizedLocalHourOfLOW_C = localHourOfLOW_C[1] 
        int   finalizedLocalMinuteOfLOW_C = localMinuteOfLOW_C[1] 
        int   finalizedBarOfHOW_C = barOfHOW_C[1] 
        int   finalizedBarOfLOW_C = barOfLOW_C[1] 
        float finalizedHTFHigh_C = htfHigh_C[1] 
        float finalizedHTFLow_C  = htfLow_C[1] 
        int   finalizedOffsetOfHOW_C = offsetOfHOW_C[1] 
        int   finalizedOffsetOfLOW_C = offsetOfLOW_C[1] 

        if i_showLabels_C
            // Calculate end time for the LTF candle
            int totalEndMinute_HOW = (finalizedLocalHourOfHOW_C * 60 + finalizedLocalMinuteOfHOW_C) + chartDurationInMinutes 
            int howEndHour = (totalEndMinute_HOW / 60) 
            int howEndMinute = totalEndMinute_HOW % 60 
           
            int totalEndMinute_LOW = (finalizedLocalHourOfLOW_C * 60 + finalizedLocalMinuteOfLOW_C) + chartDurationInMinutes 
            int lowEndHour = (totalEndMinute_LOW / 60) 
            int lowEndMinute = totalEndMinute_LOW % 60 

            string ltfStr = f_formatTimeframe(timeframe.period) // FIX: Use formatted LTF string
            string htfStr = f_formatTimeframe(i_customHTF) // FIX: Use formatted HTF string

            string howDayStr = f_dayToString(finalizedLocalDayOfHOW_C) 
            string howStartTimeStr = f_timeToString(finalizedLocalHourOfHOW_C, finalizedLocalMinuteOfHOW_C) 
            string howEndTimeStr = f_timeToString(howEndHour, howEndMinute) 
            string howLabelText = ltfStr + " High of " + htfStr + "\n" + howDayStr + " " + howStartTimeStr + " - " + howEndTimeStr

            string lowDayStr = f_dayToString(finalizedLocalDayOfLOW_C) 
            string lowStartTimeStr = f_timeToString(finalizedLocalHourOfLOW_C, finalizedLocalMinuteOfLOW_C) 
            string lowEndTimeStr = f_timeToString(lowEndHour, lowEndMinute) 
            string lowLabelText = ltfStr + " Low of " + htfStr + "\n" + lowDayStr + " " + lowStartTimeStr + " - " + lowEndTimeStr
           
            if not na(finalizedBarOfHOW_C) 
                label.new(finalizedBarOfHOW_C, finalizedHTFHigh_C, howLabelText, yloc = yloc.abovebar, color = i_howLabelColor_C, textcolor = color.white, style = label.style_label_down) 
            if not na(finalizedBarOfLOW_C) 
                label.new(finalizedBarOfLOW_C, finalizedHTFLow_C, lowLabelText, yloc = yloc.belowbar, color = i_lowLabelColor_C, textcolor = color.white, style = label.style_label_up) 

        // Store history
        if not na(finalizedUtcMinutesOfHOW_C) // FIX: Renamed
            array.push(howHistory_C, finalizedUtcMinutesOfHOW_C) // FIX: Renamed
            array.push(offsetHistory_C, finalizedOffsetOfHOW_C) 
        if not na(finalizedUtcMinutesOfLOW_C) // FIX: Renamed
            array.push(lowHistory_C, finalizedUtcMinutesOfLOW_C) // FIX: Renamed
            array.push(offsetHistory_C, finalizedOffsetOfLOW_C) 

        // Prune history
        while array.size(howHistory_C) > MAX_LOOKBACK 
            array.shift(howHistory_C) 
        while array.size(lowHistory_C) > MAX_LOOKBACK 
            array.shift(lowHistory_C) 
        while array.size(offsetHistory_C) > (MAX_LOOKBACK * 2) 
            array.shift(offsetHistory_C)

        // Reset trackers for new HTF period
        htfHigh_C := high 
        htfLow_C  := low 
        utcMinutesOfHOW_C := currentUtcMinutes_C // FIX: Renamed
        utcMinutesOfLOW_C := currentUtcMinutes_C // FIX: Renamed
        localDayOfHOW_C := currentLocalDay_C 
        localHourOfHOW_C := currentLocalHour_C 
        localMinuteOfHOW_C := currentLocalMinute_C 
        localDayOfLOW_C := currentLocalDay_C 
        localHourOfLOW_C := currentLocalHour_C 
        localMinuteOfLOW_C := currentLocalMinute_C 
        barOfHOW_C := bar_index 
        barOfLOW_C := bar_index 
        offsetOfHOW_C := currentOffset_C 
        offsetOfLOW_C := currentOffset_C 
    else
        // Update trackers during the HTF period
        if high > htfHigh_C 
            htfHigh_C := high 
            utcMinutesOfHOW_C := currentUtcMinutes_C // FIX: Renamed
            localDayOfHOW_C := currentLocalDay_C 
            localHourOfHOW_C := currentLocalHour_C 
            localMinuteOfHOW_C := currentLocalMinute_C 
            barOfHOW_C := bar_index 
            offsetOfHOW_C := currentOffset_C 
        if low < htfLow_C 
            htfLow_C  := low 
            utcMinutesOfLOW_C := currentUtcMinutes_C // FIX: Renamed
            localDayOfLOW_C := currentLocalDay_C 
            localHourOfLOW_C := currentLocalHour_C 
            localMinuteOfLOW_C := currentLocalMinute_C 
            barOfLOW_C := bar_index 
            offsetOfLOW_C := currentOffset_C 

// --- SESSION LOGIC BLOCK (NEW) ---
if runSessionLogic
    // Get current bar's time info
    int currentUtcMinutes_S = (hour(time, "Etc/UTC") * 60) + minute(time, "Etc/UTC")
    int currentOffset_S = f_calculateOffset(time, i_hourlyTimezone) // Use shared timezone

    // --- 1. Finalize Previous Session ---
    if isSessionEnd_S
        // Get data from the *previous* bar, which was the last bar *in* the session
        int   finalizedUtcMinsHigh_S = utcMinutesOfHigh_S[1]
        int   finalizedUtcMinsLow_S = utcMinutesOfLow_S[1]
        int   finalizedBarHigh_S = barOfHigh_S[1]
        int   finalizedBarLow_S = barOfLow_S[1]
        float finalizedHigh_S = sessionHigh_S[1]
        float finalizedLow_S = sessionLow_S[1]
        int   finalizedLocalHourHigh_S = localHourOfHigh_S[1]
        int   finalizedLocalMinHigh_S = localMinOfHigh_S[1]
        int   finalizedLocalHourLow_S = localHourOfLow_S[1]
        int   finalizedLocalMinLow_S = localMinOfLow_S[1]
        int   finalizedOffsetHigh_S = offsetOfHigh_S[1]
        int   finalizedOffsetLow_S = offsetOfLow_S[1]

        // --- Store in History ---
        if not na(finalizedUtcMinsHigh_S)
            array.push(howHistory_S, finalizedUtcMinsHigh_S)
            array.push(offsetHistory_S, finalizedOffsetHigh_S)
        if not na(finalizedUtcMinsLow_S)
            array.push(lowHistory_S, finalizedUtcMinsLow_S)
            array.push(offsetHistory_S, finalizedOffsetLow_S)

        // --- Prune History ---
        while array.size(howHistory_S) > MAX_LOOKBACK
            array.shift(howHistory_S)
        while array.size(lowHistory_S) > MAX_LOOKBACK
            array.shift(lowHistory_S)
        while array.size(offsetHistory_S) > (MAX_LOOKBACK * 2)
            array.shift(offsetHistory_S)

        // --- Draw Labels ---
        if i_showLabels_S
            int totalEndMinuteH_S = (finalizedLocalHourHigh_S * 60 + finalizedLocalMinHigh_S) + chartDurationInMinutes
            int endHourH_S = (totalEndMinuteH_S / 60)
            int endMinH_S = totalEndMinuteH_S % 60
           
            int totalEndMinuteL_S = (finalizedLocalHourLow_S * 60 + finalizedLocalMinLow_S) + chartDurationInMinutes
            int endHourL_S = (totalEndMinuteL_S / 60)
            int endMinL_S = totalEndMinuteL_S % 60

            string tfStr_S = f_formatTimeframe(timeframe.period)
            string startTimeStrH_S = f_timeToString(finalizedLocalHourHigh_S, finalizedLocalMinHigh_S)
            string endTimeStrH_S = f_timeToString(endHourH_S, endMinH_S)
            string labelTextH_S = tfStr_S + " Session High\n" + startTimeStrH_S + " - " + endTimeStrH_S

            string startTimeStrL_S = f_timeToString(finalizedLocalHourLow_S, finalizedLocalMinLow_S)
            string endTimeStrL_S = f_timeToString(endHourL_S, endMinL_S)
            string labelTextL_S = tfStr_S + " Session Low\n" + startTimeStrL_S + " - " + endTimeStrL_S
           
            if not na(finalizedBarHigh_S)
                label.new(finalizedBarHigh_S, finalizedHigh_S, labelTextH_S, yloc = yloc.abovebar, color = i_highLabelColor_S, textcolor = color.white, style = label.style_label_down)
            if not na(finalizedBarLow_S)
                label.new(finalizedBarLow_S, finalizedLow_S, labelTextL_S, yloc = yloc.belowbar, color = i_lowLabelColor_S, textcolor = color.white, style = label.style_label_up)

    // --- 2. Reset on New Session ---
    if isSessionStart_S
        sessionHigh_S := high
        sessionLow_S := low
        barOfHigh_S := bar_index
        barOfLow_S := bar_index
        utcMinutesOfHigh_S := currentUtcMinutes_S
        utcMinutesOfLow_S := currentUtcMinutes_S
        localHourOfHigh_S := localHour_S
        localMinOfHigh_S := localMinute_S
        localHourOfLow_S := localHour_S
        localMinOfLow_S := localMinute_S
        offsetOfHigh_S := currentOffset_S
        offsetOfLow_S := currentOffset_S

    // --- 3. Track During Session ---
    else if inSession_S
        if high > sessionHigh_S
            sessionHigh_S := high
            barOfHigh_S := bar_index
            utcMinutesOfHigh_S := currentUtcMinutes_S
            localHourOfHigh_S := localHour_S
            localMinOfHigh_S := localMinute_S
            offsetOfHigh_S := currentOffset_S
        if low < sessionLow_S
            sessionLow_S := low
            barOfLow_S := bar_index
            utcMinutesOfLow_S := currentUtcMinutes_S
            localHourOfLow_S := localHour_S
            localMinOfLow_S := localMinute_S
            offsetOfLow_S := currentOffset_S


// --- MODULE DIVIDER LOGIC ---
if runDailyLogic and i_showDivider_D and isNewWeek
    line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted)
    if i_showDividerLabels
        label.new(bar_index, low, "Weekly", yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small)

if runWOMLogic and i_showDivider_WOM and isNewMonth
    line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted)
    if i_showDividerLabels
        label.new(bar_index, low, "Monthly", yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small)

if runMOYLogic and i_showDivider_MOY and isNewYear
    line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted)
    if i_showDividerLabels
        label.new(bar_index, low, "Yearly", yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small)

if runCustomLogic and i_showDivider_C and isNewCustomHTF 
    line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted)
    if i_showDividerLabels
        label.new(bar_index, low, f_formatTimeframe(i_customHTF), yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small)
    
// NEW Session Divider Logic
if runSessionLogic and i_showDividers_S
    string sTimeStr = f_timeToString(sessionStartHour_S, sessionStartMin_S)
    string eTimeStr = f_timeToString(sessionEndHour_S, sessionEndMin_S)
   
    if isSessionStart_S
        line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted) 
        if i_showDividerLabels
            label.new(bar_index, low, sTimeStr, yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small) 
    if isSessionEnd_S
        line.new(bar_index, high, bar_index, low, extend = extend.both, color = i_dividerColor, style = line.style_dotted) 
        if i_showDividerLabels
            label.new(bar_index, low, eTimeStr, yloc = yloc.belowbar, style = label.style_none, textcolor = i_dividerColor, size = size.small)


// === TABLE HELPER FUNCTIONS ===
f_fillCell(tbl, col, row, cellText, bgColor, txtColor, txtSize) =>
    table.cell(tbl, col, row, cellText, text_color = txtColor, bgcolor = bgColor, text_size = txtSize)

// UPDATED: Added 'txtColor' parameter, removed bolding
f_drawHeader(tbl, col, row, headerText, txtSize, txtColor = color.white) =>
    f_fillCell(tbl, col, row, headerText, color.new(color.gray, 20), txtColor, txtSize)

// Daily table row
f_drawRow_Daily(tbl, row, index, name, howCounts, lowCounts, totalWeeks, maxHowCount, maxLowCount, txtSize) =>
    int howVal = array.get(howCounts, index)
    int lowVal = array.get(lowCounts, index)
    float howPct = (howVal / totalWeeks)*100
    float lowPct = (lowVal / totalWeeks) * 100
    color howColor = color.from_gradient(howVal, 0.0, maxHowCount, color.new(color.teal, 90), color.new(color.teal, 30))
    color lowColor = color.from_gradient(lowVal, 0.0, maxLowCount, color.new(color.red, 90), color.new(color.red, 30))
    f_fillCell(tbl, 0, row, name, color.new(color.gray, 20), color.white, txtSize)
    f_fillCell(tbl, 1, row, str.tostring(howVal), howColor, color.white, txtSize)
    f_fillCell(tbl, 2, row, str.tostring(howPct, "0.0") + "%", howColor, color.white, txtSize)
    f_fillCell(tbl, 3, row, str.tostring(lowVal), lowColor, color.white, txtSize)
    f_fillCell(tbl, 4, row, str.tostring(lowPct, "0.0") + "%", lowColor, color.white, txtSize)

// Custom table helper function
// UPDATED: Added 'stdColor' and 'dstColor' parameters
f_drawRow_Custom_Merged(tbl, row, 
      timeStrA, timeStrB,
      howCounts, lowCounts, 
      utcMinutes, 
      totalPeriods, maxHOW, maxLOW, 
      txtSize,
      stdColor, dstColor) => // New params
    int howVal = nz(howCounts.get(utcMinutes), 0) 
    int lowVal = nz(lowCounts.get(utcMinutes), 0) 
    float howPct = (howVal / totalPeriods) * 100 
    float lowPct = (lowVal / totalPeriods) * 100 
    color howColor = color.from_gradient(howVal, 0.0, maxHOW, color.new(color.teal, 90), color.new(color.teal, 30)) 
    color lowColor = color.from_gradient(lowVal, 0.0, maxLOW, color.new(color.red, 90), color.new(color.red, 30)) 
   
    f_fillCell(tbl, 0, row, timeStrA, color.new(color.gray, 20), stdColor, txtSize)
    f_fillCell(tbl, 1, row, timeStrB, color.new(color.gray, 20), dstColor, txtSize)
    f_fillCell(tbl, 2, row, str.tostring(howVal), howColor, color.white, txtSize) 
    f_fillCell(tbl, 3, row, str.tostring(howPct, "0.0") + "%", howColor, color.white, txtSize)
    f_fillCell(tbl, 4, row, str.tostring(lowVal), lowColor, color.white, txtSize) 
    f_fillCell(tbl, 5, row, str.tostring(lowPct, "0.0") + "%", lowColor, color.white, txtSize)

// Session table helper function
// UPDATED: Added 'stdColor' and 'dstColor' parameters
f_drawRow_Session_Merged(tbl, row, 
      timeStrA, timeStrB,
      howCounts, lowCounts, 
      utcMinutes, 
      totalPeriods, maxHOW, maxLOW, 
      txtSize,
      stdColor, dstColor) => // New params
    int howVal = nz(howCounts.get(utcMinutes), 0)
    int lowVal = nz(lowCounts.get(utcMinutes), 0)
    float howPct = (howVal / totalPeriods) * 100 
    float lowPct = (lowVal / totalPeriods) * 100 
    color howColor = color.from_gradient(howVal, 0.0, maxHOW, color.new(color.teal, 90), color.new(color.teal, 30)) 
    color lowColor = color.from_gradient(lowVal, 0.0, maxLOW, color.new(color.red, 90), color.new(color.red, 30)) 
   
    f_fillCell(tbl, 0, row, timeStrA, color.new(color.gray, 20), stdColor, txtSize)
    f_fillCell(tbl, 1, row, timeStrB, color.new(color.gray, 20), dstColor, txtSize)
    f_fillCell(tbl, 2, row, str.tostring(howVal), howColor, color.white, txtSize) 
    f_fillCell(tbl, 3, row, str.tostring(howPct, "0.0") + "%", howColor, color.white, txtSize)
    f_fillCell(tbl, 4, row, str.tostring(lowVal), lowColor, color.white, txtSize) 
    f_fillCell(tbl, 5, row, str.tostring(lowPct, "0.0") + "%", lowColor, color.white, txtSize)


// Monthly (WOM) table row
f_drawRow_WOM(tbl, row, index, name, howCounts, lowCounts, totalMonths, maxHowCount, maxLowCount, txtSize) =>
    int howVal = array.get(howCounts, index)
    int lowVal = array.get(lowCounts, index)
    float howPct = (howVal / totalMonths)*100
    float lowPct = (lowVal / totalMonths) * 100
    color howColor = color.from_gradient(howVal, 0.0, maxHowCount, color.new(color.teal, 90), color.new(color.teal, 30)) 
    color lowColor = color.from_gradient(lowVal, 0.0, maxLowCount, color.new(color.red, 90), color.new(color.red, 30)) 
    f_fillCell(tbl, 0, row, name, color.new(color.gray, 20), color.white, txtSize)
    f_fillCell(tbl, 1, row, str.tostring(howVal), howColor, color.white, txtSize)
    f_fillCell(tbl, 2, row, str.tostring(howPct, "0.0") + "%", howColor, color.white, txtSize)
    f_fillCell(tbl, 3, row, str.tostring(lowVal), lowColor, color.white, txtSize)
    f_fillCell(tbl, 4, row, str.tostring(lowPct, "0.0") + "%", lowColor, color.white, txtSize)

// Yearly (MOY) table row
f_drawRow_MOY(tbl, row, index, name, howCounts, lowCounts, totalYears, maxHowCount, maxLowCount, txtSize) =>
    int howVal = array.get(howCounts, index)
    int lowVal = array.get(lowCounts, index)
    float howPct = (howVal / totalYears) * 100 
    float lowPct = (lowVal / totalYears) * 100
    color howColor = color.from_gradient(howVal, 0.0, maxHowCount, color.new(color.teal, 90), color.new(color.teal, 30)) 
    color lowColor = color.from_gradient(lowVal, 0.0, maxLowCount, color.new(color.red, 90), color.new(color.red, 30)) 
    f_fillCell(tbl, 0, row, name, color.new(color.gray, 20), color.white, txtSize)
    f_fillCell(tbl, 1, row, str.tostring(howVal), howColor, color.white, txtSize)
    f_fillCell(tbl, 2, row, str.tostring(howPct, "0.0") + "%", howColor, color.white, txtSize)
    f_fillCell(tbl, 3, row, str.tostring(lowVal), lowColor, color.white, txtSize)
    f_fillCell(tbl, 4, row, str.tostring(lowPct, "0.0") + "%", lowColor, color.white, txtSize)


// === DAILY TABLE DRAWING ===
if runDailyLogic and barstate.islast and i_showDailyTable 
    int[] howCounts_D = array.new_int(8, 0)
    int[] lowCounts_D = array.new_int(8, 0)
    for dayVal in howHistory_D
        if dayVal >= 1 and dayVal <= 7
            array.set(howCounts_D, dayVal, array.get(howCounts_D, dayVal) + 1)
    for dayVal in lowHistory_D
        if dayVal >= 1 and dayVal <= 7
            array.set(lowCounts_D, dayVal, array.get(lowCounts_D, dayVal) + 1)
    float totalWeeks_D = math.max(array.size(howHistory_D), 1.0)
    float maxHowCount_D = math.max(array.max(howCounts_D), 1.0)
    float maxLowCount_D = math.max(array.max(lowCounts_D), 1.0)
    var table t_D = table.new(i_tablePos_D, 5, 9, border_width = 1)
    table.clear(t_D, 0, 0, 4, 8)
    int row_D = 0 
    f_drawHeader(t_D, 0, row_D, "Daily high and low of the week", i_tableSize_D) 
    f_drawHeader(t_D, 1, row_D, "Daily HIGH #", i_tableSize_D) 
    f_drawHeader(t_D, 2, row_D, "Daily HIGH %", i_tableSize_D) 
    f_drawHeader(t_D, 3, row_D, "Daily LOW #", i_tableSize_D) 
    f_drawHeader(t_D, 4, row_D, "Daily LOW %", i_tableSize_D) 
    row_D += 1 
    if i_showSun
        f_drawRow_Daily(t_D, row_D, dayofweek.sunday, "Sunday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
        row_D += 1
    f_drawRow_Daily(t_D, row_D, dayofweek.monday, "Monday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
    row_D += 1
    f_drawRow_Daily(t_D, row_D, dayofweek.tuesday, "Tuesday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
    row_D += 1
    f_drawRow_Daily(t_D, row_D, dayofweek.wednesday, "Wednesday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
    row_D += 1
    f_drawRow_Daily(t_D, row_D, dayofweek.thursday, "Thursday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
    row_D += 1
    f_drawRow_Daily(t_D, row_D, dayofweek.friday, "Friday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
    row_D += 1
    if i_showSat
        f_drawRow_Daily(t_D, row_D, dayofweek.saturday, "Saturday", howCounts_D, lowCounts_D, totalWeeks_D, maxHowCount_D, maxLowCount_D, i_tableSize_D)
        row_D += 1
    table.cell(t_D, 0, row_D, "Total Weeks: " + str.tostring(array.size(howHistory_D)), text_color = color.gray, text_halign = text.align_center, text_size = i_tableSize_D)
    table.merge_cells(t_D, 0, row_D, 4, row_D)

// === MONTHLY (WOM) TABLE DRAWING ===
if runWOMLogic and barstate.islast and i_showWOMTable 
    int[] mohCounts = array.new_int(6, 0)
    int[] molCounts = array.new_int(6, 0)
    for weekVal in mohHistory
        if weekVal >= 1 and weekVal <= 5 
            array.set(mohCounts, weekVal, array.get(mohCounts, weekVal) + 1)
    for weekVal in molHistory
        if weekVal >= 1 and weekVal <= 5 
            array.set(molCounts, weekVal, array.get(molCounts, weekVal) + 1)
           
    float totalMonths = math.max(array.size(mohHistory), 1.0)
    float maxMOH = math.max(array.max(mohCounts), 1.0)
    float maxMOL = math.max(array.max(molCounts), 1.0)
   
    var table t_WOM = table.new(i_tablePos_WOM, 5, 7, border_width = 1) 
    table.clear(t_WOM, 0, 0, 4, 6) 
    int row_WOM = 0

    f_drawHeader(t_WOM, 0, row_WOM, "Weekly high and low of the month", i_tableSize_WOM) 
    f_drawHeader(t_WOM, 1, row_WOM, "Weekly HIGH #", i_tableSize_WOM) 
    f_drawHeader(t_WOM, 2, row_WOM, "Weekly HIGH %", i_tableSize_WOM) 
    f_drawHeader(t_WOM, 3, row_WOM, "Weekly LOW #", i_tableSize_WOM) 
    f_drawHeader(t_WOM, 4, row_WOM, "Weekly LOW %", i_tableSize_WOM) 
    row_WOM += 1

    f_drawRow_WOM(t_WOM, row_WOM, 1, "Week 1", mohCounts, molCounts, totalMonths, maxMOH, maxMOL, i_tableSize_WOM)
    row_WOM += 1
    f_drawRow_WOM(t_WOM, row_WOM, 2, "Week 2", mohCounts, molCounts, totalMonths, maxMOH, maxMOL, i_tableSize_WOM)
    row_WOM += 1
    f_drawRow_WOM(t_WOM, row_WOM, 3, "Week 3", mohCounts, molCounts, totalMonths, maxMOH, maxMOL, i_tableSize_WOM)
    row_WOM += 1
    f_drawRow_WOM(t_WOM, row_WOM, 4, "Week 4", mohCounts, molCounts, totalMonths, maxMOH, maxMOL, i_tableSize_WOM)
    row_WOM += 1
    f_drawRow_WOM(t_WOM, row_WOM, 5, "Week 5", mohCounts, molCounts, totalMonths, maxMOH, maxMOL, i_tableSize_WOM)
    row_WOM += 1
   
    table.cell(t_WOM, 0, row_WOM, "Total Months: " + str.tostring(totalMonths, "0"), text_color = color.gray, text_halign = text.align_center, text_size = i_tableSize_WOM)
    table.merge_cells(t_WOM, 0, row_WOM, 4, row_WOM)
   
// === YEARLY (MOY) TABLE DRAWING ===
if runMOYLogic and barstate.islast and i_showMOYTable 
    int[] moyhCounts = array.new_int(13, 0)
    int[] molyCounts = array.new_int(13, 0) 
    for monthVal in moyhHistory
        if monthVal >= 1 and monthVal <= 12
            array.set(moyhCounts, monthVal, array.get(moyhCounts, monthVal) + 1)
    for monthVal in molyHistory 
        if monthVal >= 1 and monthVal <= 12
            array.set(molyCounts, monthVal, array.get(molyCounts, monthVal) + 1) 

    float totalYears = math.max(array.size(moyhHistory), 1.0)
    float maxYOH = math.max(array.max(moyhCounts), 1.0)
    float maxYOL = math.max(array.max(molyCounts), 1.0) 

    var table t_MOY = table.new(i_tablePos_MOY, 5, 14, border_width = 1)
    table.clear(t_MOY, 0, 0, 4, 13)
    int row_MOY = 0

    f_drawHeader(t_MOY, 0, row_MOY, "Monthly high and low of the year", i_tableSize_MOY) 
    f_drawHeader(t_MOY, 1, row_MOY, "Monthly HIGH #", i_tableSize_MOY) 
    f_drawHeader(t_MOY, 2, row_MOY, "Monthly HIGH %", i_tableSize_MOY) 
    f_drawHeader(t_MOY, 3, row_MOY, "Monthly LOW #", i_tableSize_MOY) 
    f_drawHeader(t_MOY, 4, row_MOY, "Monthly LOW %", i_tableSize_MOY) 
    row_MOY += 1

    for i = 1 to 12
        f_drawRow_MOY(t_MOY, row_MOY, i, f_monthToString(i), moyhCounts, molyCounts, totalYears, maxYOH, maxYOL, i_tableSize_MOY) 
        row_MOY += 1
       
    table.cell(t_MOY, 0, row_MOY, "Total Years: " + str.tostring(totalYears, "0"), text_color = color.gray, text_halign = text.align_center, text_size = i_tableSize_MOY)
    table.merge_cells(t_MOY, 0, row_MOY, 4, row_MOY)

// === CUSTOM MERGED TABLE DRAWING ===
if runCustomLogic and barstate.islast and i_showCustomTable
    map<int, int> howCounts_C = map.new<int, int>()
    map<int, int> lowCounts_C = map.new<int, int>()
   
    for utcMinutesVal in howHistory_C
        howCounts_C.put(utcMinutesVal, nz(howCounts_C.get(utcMinutesVal), 0) + 1) 
    for utcMinutesVal in lowHistory_C
        lowCounts_C.put(utcMinutesVal, nz(lowCounts_C.get(utcMinutesVal), 0) + 1) 

    int[] uniqueOffsets_C = array.new<int>()
    for offset in offsetHistory_C
        if array.indexof(uniqueOffsets_C, offset) == -1
            array.push(uniqueOffsets_C, offset)
           
    int offset1_C = array.size(uniqueOffsets_C) > 0 ? array.get(uniqueOffsets_C, 0) : 0
    int offset2_C = array.size(uniqueOffsets_C) > 1 ? array.get(uniqueOffsets_C, 1) : offset1_C 
   
    int stdOffset_C = math.min(offset1_C, offset2_C)
    int dstOffset_C = math.max(offset1_C, offset2_C)
   
    string stdStr_C = "Time (STD)" 
    string dstStr_C = "Time (DST)" 
    if stdOffset_C == dstOffset_C 
        stdStr_C := "Time (Local)" 
        dstStr_C := "Time (Local)" 
       
    // Determine current active offset
    int currentOffset_C = f_calculateOffset(timenow, i_hourlyTimezone)
    bool stdIsActive_C = currentOffset_C == stdOffset_C
    bool dstIsActive_C = currentOffset_C == dstOffset_C

    // Determine colors
    color stdColor_C = color.white
    color dstColor_C = color.white
    if i_highlightActiveTimezone
        stdColor_C := stdIsActive_C ? color.white : color.gray
        dstColor_C := dstIsActive_C ? color.white : color.gray

    float totalPeriods_C = math.max(array.size(howHistory_C), 1.0) 
    float maxHOW_C = math.max(array.size(howCounts_C.values()) > 0 ? array.max(howCounts_C.values()) : 0, 1.0)
    float maxLOW_C = math.max(array.size(lowCounts_C.values()) > 0 ? array.max(lowCounts_C.values()) : 0, 1.0)
   
    int[] utcMinutesToShow_C = array.new<int>()
    int[] howKeys = howCounts_C.keys()
    int[] lowKeys = lowCounts_C.keys()
    for key in howKeys
        array.push(utcMinutesToShow_C, key)
    for key in lowKeys
        if array.indexof(utcMinutesToShow_C, key) == -1
            array.push(utcMinutesToShow_C, key)
    array.sort(utcMinutesToShow_C) // Sort the minutes chronologically
   
    int[] sortedUtcMinutesToShow_C = array.new<int>()
   
    if i_limitCustomRows
        map<int, int> totalCounts_C = map.new<int, int>()
        for key in howCounts_C.keys()
            totalCounts_C.put(key, nz(totalCounts_C.get(key), 0) + howCounts_C.get(key))
        for key in lowCounts_C.keys()
            totalCounts_C.put(key, nz(totalCounts_C.get(key), 0) + lowCounts_C.get(key))

        int[] totalCountsArray_C = array.new<int>()
        for utcMinute in utcMinutesToShow_C
            array.push(totalCountsArray_C, totalCounts_C.get(utcMinute))
           
        int[] sortedIndices = array.sort_indices(totalCountsArray_C, order.descending)
       
        for index in sortedIndices
            array.push(sortedUtcMinutesToShow_C, array.get(utcMinutesToShow_C, index))
           
        if array.size(sortedUtcMinutesToShow_C) > i_maxCustomRows
            sortedUtcMinutesToShow_C := array.slice(sortedUtcMinutesToShow_C, 0, i_maxCustomRows) 
    else
        sortedUtcMinutesToShow_C := utcMinutesToShow_C
           
    int numRows_C = array.size(sortedUtcMinutesToShow_C) + 3 
    var table t_C = table.new(i_tablePos_C, 6, numRows_C, border_width = 1) 
    table.clear(t_C, 0, 0, 5, numRows_C - 1) 
    int row_C = 0 

    string titleText = f_formatTimeframe(timeframe.period) + " high and low of " + f_formatTimeframe(i_customHTF) // FIX: Use formatted timeframes
    table.cell(t_C, 0, row_C, titleText, text_color = color.white, text_halign = text.align_center, text_size = i_tableSize_C, bgcolor = color.new(color.gray, 20))
    table.merge_cells(t_C, 0, row_C, 5, row_C) 
    row_C += 1

    f_drawHeader(t_C, 0, row_C, stdStr_C, i_tableSize_C, stdColor_C) // Pass color
    f_drawHeader(t_C, 1, row_C, dstStr_C, i_tableSize_C, dstColor_C) // Pass color
    f_drawHeader(t_C, 2, row_C, "LTF HIGH #", i_tableSize_C) 
    f_drawHeader(t_C, 3, row_C, "LTF HIGH %", i_tableSize_C) 
    f_drawHeader(t_C, 4, row_C, "LTF LOW #", i_tableSize_C)
    f_drawHeader(t_C, 5, row_C, "LTF LOW %", i_tableSize_C)
    row_C += 1

    for utcMinutesVal in sortedUtcMinutesToShow_C 
        int utcHour = utcMinutesVal / 60
        int utcMinute = utcMinutesVal % 60
        string timeStrStd = f_timeToString(utcHour + stdOffset_C, utcMinute) 
        string timeStrDst = f_timeToString(utcHour + dstOffset_C, utcMinute) 
       
        f_drawRow_Custom_Merged(t_C, row_C,
           timeStrStd, timeStrDst, 
           howCounts_C, lowCounts_C, 
           utcMinutesVal,
           totalPeriods_C, maxHOW_C, maxLOW_C, 
           i_tableSize_C,
           stdColor_C, dstColor_C) // Pass colors
        row_C += 1
       
    string footerText = "Total " + i_customHTF + " Periods: " + str.tostring(totalPeriods_C, "0") 
    table.cell(t_C, 0, row_C, footerText, text_color = color.gray, text_halign = text.align_center, text_size = i_tableSize_C)
    table.merge_cells(t_C, 0, row_C, 5, row_C)
   
// === SESSION MERGED TABLE DRAWING (NEW) ===
if runSessionLogic and i_showTable_S and barstate.islast
    // Use Maps to store counts, keyed by UTC minute (0-1439)
    map<int, int> howCounts_S_tbl = map.new<int, int>()
    map<int, int> lowCounts_S_tbl = map.new<int, int>()
   
    // Populate maps from history
    for utcMinutesVal in howHistory_S
        howCounts_S_tbl.put(utcMinutesVal, nz(howCounts_S_tbl.get(utcMinutesVal), 0) + 1) 
    for utcMinutesVal in lowHistory_S
        lowCounts_S_tbl.put(utcMinutesVal, nz(lowCounts_S_tbl.get(utcMinutesVal), 0) + 1) 

    // Find the unique offsets (for STD/DST)
    int[] uniqueOffsets_S = array.new<int>()
    for offset in offsetHistory_S
        if array.indexof(uniqueOffsets_S, offset) == -1
            array.push(uniqueOffsets_S, offset)
           
    int offset1_S = array.size(uniqueOffsets_S) > 0 ? array.get(uniqueOffsets_S, 0) : 0
    int offset2_S = array.size(uniqueOffsets_S) > 1 ? array.get(uniqueOffsets_S, 1) : offset1_S 
   
    int stdOffset_S = math.min(offset1_S, offset2_S)
    int dstOffset_S = math.max(offset1_S, offset2_S)
   
    string stdStr_S = "Time (STD)"
    string dstStr_S = "Time (DST)"
    if stdOffset_S == dstOffset_S 
        stdStr_S := "Time (Local)"
        dstStr_S := "Time (Local)"

    // Determine current active offset
    int currentOffset_S = f_calculateOffset(timenow, i_hourlyTimezone)
    bool stdIsActive_S = currentOffset_S == stdOffset_S
    bool dstIsActive_S = currentOffset_S == dstOffset_S

    // Determine colors
    color stdColor_S = color.white
    color dstColor_S = color.white
    if i_highlightActiveTimezone
        stdColor_S := stdIsActive_S ? color.white : color.gray
        dstColor_S := dstIsActive_S ? color.white : color.gray

    // Get max counts for color gradients
    float totalSessions_S = math.max(array.size(howHistory_S), 1.0) 
    float maxHOW_S = math.max(array.size(howCounts_S_tbl.values()) > 0 ? array.max(howCounts_S_tbl.values()) : 0, 1.0)
    float maxLOW_S = math.max(array.size(lowCounts_S_tbl.values()) > 0 ? array.max(lowCounts_S_tbl.values()) : 0, 1.0)
   
    // Get all unique candle times that made a high or low
    int[] utcMinutesToShow_S = array.new<int>()
    for key in howCounts_S_tbl.keys()
        array.push(utcMinutesToShow_S, key)
    for key in lowCounts_S_tbl.keys()
        if array.indexof(utcMinutesToShow_S, key) == -1
            array.push(utcMinutesToShow_S, key)
   
    // Sort the list of times
    int[] sortedUtcMinutesToShow_S = array.new<int>()
   
    if i_limitRows_S
        // Sort by frequency
        map<int, int> totalCounts_S = map.new<int, int>()
        for key in howCounts_S_tbl.keys()
            totalCounts_S.put(key, nz(totalCounts_S.get(key), 0) + howCounts_S_tbl.get(key))
        for key in lowCounts_S_tbl.keys()
            totalCounts_S.put(key, nz(totalCounts_S.get(key), 0) + lowCounts_S_tbl.get(key))

        int[] totalCountsArray_S = array.new<int>()
        for utcMinute in utcMinutesToShow_S
            array.push(totalCountsArray_S, totalCounts_S.get(utcMinute))
           
        int[] sortedIndices = array.sort_indices(totalCountsArray_S, order.descending)
       
        for index in sortedIndices
            array.push(sortedUtcMinutesToShow_S, array.get(utcMinutesToShow_S, index))
           
        if array.size(sortedUtcMinutesToShow_S) > i_maxRows_S
            sortedUtcMinutesToShow_S := array.slice(sortedUtcMinutesToShow_S, 0, i_maxRows_S)
    else
        // Sort chronologically
        array.sort(utcMinutesToShow_S)
        sortedUtcMinutesToShow_S := utcMinutesToShow_S
           
    // --- Draw the Table ---
    int numRows_S = array.size(sortedUtcMinutesToShow_S) + 3 // +3 for Title, Header, Footer
    var table t_S = table.new(i_tablePos_S, 6, numRows_S, border_width = 1) 
    table.clear(t_S, 0, 0, 5, numRows_S - 1) 
    int row_S = 0 

    string titleText_S = "Session High/Low Statistics (" + f_formatTimeframe(timeframe.period) + ")"
    table.cell(t_S, 0, row_S, titleText_S, text_color = color.white, text_halign = text.align_center, text_size = i_tableSize_S, bgcolor = color.new(color.gray, 20))
    table.merge_cells(t_S, 0, row_S, 5, row_S) 
    row_S += 1

    f_drawHeader(t_S, 0, row_S, stdStr_S, i_tableSize_S, stdColor_S) // Pass color
    f_drawHeader(t_S, 1, row_S, dstStr_S, i_tableSize_S, dstColor_S) // Pass color
    f_drawHeader(t_S, 2, row_S, "Sess HIGH #", i_tableSize_S) 
    f_drawHeader(t_S, 3, row_S, "Sess HIGH %", i_tableSize_S) 
    f_drawHeader(t_S, 4, row_S, "Sess LOW #", i_tableSize_S)
    f_drawHeader(t_S, 5, row_S, "Sess LOW %", i_tableSize_S)
    row_S += 1

    for utcMinutesVal in sortedUtcMinutesToShow_S 
        int utcHour = utcMinutesVal / 60
        int utcMinute = utcMinutesVal % 60
        // Show the candle's START time in both STD and DST
        string timeStrStd = f_timeToString(utcHour + stdOffset_S, utcMinute) 
        string timeStrDst = f_timeToString(utcHour + dstOffset_S, utcMinute) 
       
        f_drawRow_Session_Merged(t_S, row_S,
             timeStrStd, timeStrDst, 
             howCounts_S_tbl, lowCounts_S_tbl, 
             utcMinutesVal,
             totalSessions_S, maxHOW_S, maxLOW_S, 
             i_tableSize_S,
             stdColor_S, dstColor_S) // Pass colors
        row_S += 1
       
    string footerText_S = "Total Sessions: " + str.tostring(totalSessions_S, "0") 
    table.cell(t_S, 0, row_S, footerText_S, text_color = color.gray, text_halign = text.align_center, text_size = i_tableSize_S)
    table.merge_cells(t_S, 0, row_S, 5, row_S)
